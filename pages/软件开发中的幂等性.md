- #+BEGIN_QUOTE
  最近总是被问到幂等性的问题，觉得有必要总结和梳理一下。
  #+END_QUOTE
- ## 什么是幂等性
- 幂等性其实是在描述计算效应！为什么？很好的发问，首先让我们穿越时空回到小学的数学课上，那时候一切的函数是多么的朴实无华，*只要传入的参数相同，那么必然会得到同样的结果*；然而后来你了解到了状态机，了解到了基于C语言建立起来的编程语言世界，你发现原来一个函数不仅可以在相同的输入下返回不同的结果，而且还可以产生一些除了纯计算之外的副作用(side-effect)，你一开始没有思考那么多，你觉得数学上的纯函数才是虚无的理想国与乌托邦，真实的世界就是充满了副（负）作用；
- 随着编程的深入，你逐渐开始怀念起数学中的纯函数，因为你发现在不断的重构代码和修改别人的代码时，纯函数的可代换特性是如此的美妙，重构纯函数就像是数学中的等式代换一样有趣而优雅，而且无需担心副作用导致程序语义的改变，于是你开始学习函数式编程，尝试驯服副作用这个幽灵；可是现实世界是一定存在副作用的，这是无可奈何的，你这么想着，直到你遇到了monad和代数计算效应；
- 于是你终于感觉抓住了计算效应的尾巴，副作用不再像幽灵一样游走于程序的黑暗地带，而是变成了一个一个具象化的形体被你拿捏在手中，在不断的探索中，你甚至掌握了抽象副作用的能力，让你的代码与副作用完全解耦合；终于，你发现计算效应本身包含一些特殊的性质，这些性质是独立于任何计算效应之外的，无论是状态管理、错误处理、依赖注入还是IO等等，这些计算效应全部拥有一些独特的性质，其中特别重要的主要有两种：*幂等性和可逆性*；
- 对于一个函数，我们用这种语言来描述其类型：
- ```rust
  fn f<A, B>(input: A) -> Effect<B>;
  ```
- 其中Effect就是在描述函数`f`返回类型B之外所产生的额外的计算效应，幂等性就是指如果输入一致或者满足一定的约束，则这个计算效应最多只应被执行一次；
-
- ## 开发常见实现方式
- 实现的方式其实非常朴实：
	- 使用纯函数，这样计算效应就是0，0乘以任何数字都是0，永远不会有副作用
	  logseq.order-list-type:: number
	- 利用状态管理效应，如果发现该调用重复，则不再触发副作用（比如缓存？）
	  logseq.order-list-type:: number
		- 注意呦，这里的状态管理是广义上的状态管理，返回一个额外的参数并在下一次再传回来（比如token）也是一种状态管理哦！
		  logseq.order-list-type:: number