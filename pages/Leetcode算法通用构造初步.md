- 本来是想写通用的算法解法，但是目前由于我基本大部分只是在Leetcode进行了实践，还没有在更大的范围内（如ACM）进行实践，所以这里我仅仅阐述一下我对leetcode大概500到题中的发现，即：
- #+BEGIN_QUOTE
  你不需要掌握各种各样的复杂的分类与解法，所有的算法题，都可以用一种方式来解决。
  #+END_QUOTE
- 大部分同学听到这个结论基本都不太相信，不过这个结论在*可解*问题的范围内基本是通用的。理论描述过于复杂，你可以简单理解为目前的编程架构所允许的分支和循环与递归总是可以互相等价的，所以任何可以在有限步骤内被分支循环所表述的算法都可以在递归框架内描述；更准确地说，lambda演算是图灵完备的！
- 为什么提到递归和lambda演算呢？这是因为我想提出的通解用递归进行描述会十分简洁与清晰。我就不卖关子了，这个通解的模糊版语言描述就是：
- #+BEGIN_QUOTE
  任何问题都可以通过其输入和输出的数据结构进行某种方式的解构，我们顺着这种解构不断递归去解决问题直到一言可以看出答案，最后把所有递归结果合并起来，就可以得到最终的结果，其实总纲领没什么新东西，无非就是分治（Divide and conquer）罢了。
  #+END_QUOTE
- 虽然看起来平平无奇，但是里面隐藏了非常非常多的坑。这里的坑是指大部分的资料都无法贯彻这一思想，更不用提发现其中常用的技巧。这里我简单列举几个我认为比较重要的技巧帮我们快速分治：
- ## 递归转循环
- 任何递归都可以转化为对应形式的带有stack上下文的循环（实际上大部分编译器就是这么干的）。具体的方式我打算再开一篇文章未来进行描述。
- ## 递归额外信息
- 对于一个问题，我们递归的结果在大部分场景内并不是简单返回一个局部解，我发现通常我们需要一个*额外的递归信息*。这么说比较抽象，我来举个例子吧，就举我们经常喜闻乐见的滑动窗口吧：
- 滑动窗口用分治来描述十分典型：对于一个输入列表，分解为最后一个元素和前面所有元素组成的列表。假设我已经通过递归得到了前面所有元素的解（除了最后一个元素），那么会发现，单纯的一个前半部分的解不足以支撑我们把最后一个元素纳入之后得到新的解。于是我们可以简单纳入一个额外的信息，即假设前半部分的递归可以返回给我们一个额外的信息，这个额外的信息包含最后一个元素相邻的序列的某种信息（其实这个序列就是很多人称呼的滑动窗口），利用这个额外的信息我们发现可以轻而易举地更新全局解。
- 当然别忘了这个额外信息是递归的，你在要求前半部分递归返回额外信息的同时，你也要能返回更新之后的额外信息（可以类比滑动窗口的滑动更新）。这里虽然使用了滑动窗口作为例子，但是实际上额外信息这一技巧的应用范围远不止此，你会发现单调栈、双指针、前缀和等等全都只是额外信息递归的特例罢了。
- ## 不仅分解输入，分解输出！
- 一个常见的误区就是很多人认为分治只能用在分解输入参数上，实际上分解输出十分的常见而且实用，实用到什么程度呢？我们经常束手无策的时候使用的回溯就是这种分治的特例。记住：
- #+BEGIN_QUOTE
  所有的能表征问题本身的信息（数据）都可以作为分解的依据，你可以分解任何你想尝试数据，只是不同的分解策略可能导出大相径庭的算法和复杂度。
  #+END_QUOTE
- ## 一个一个分解，不要同时分解
- 与于是你开始尝试分解任何你认为可能有用的数据，但是记住永远不要去考虑多个维度的分解，而是先分解第一个数据（维度），然后再考虑要不要分解第二个维度，否则一定会陷入混乱，最典型的就是高维度的动态优化，这种问题一定不要着急一口气全部分解，心急吃不了热豆腐。
- ## 空间复用
- 再尝试设计额外信息的时候，也许你会发现存储额外信息的内存可以复用，这时候一定要尝试复用这块内存，通常可以大大降低空间复杂度。
- ## 动态规划可以看作递归的一种缓存优化
- 不用畏惧动态规划，你就把递归分治的递推式子列出来，然后拿一个hashMap缓存结果就完事了；如果你发现了其中递归不存在循环依赖，那么你连哈希都不需要，一个简单的数组加上前面提到的空间复用解一切动态规划。
-
- 最近发现Catamorphism和这种思想十分相像，你可以把一个问题想象成一个可以观测其子问题的codata，然后你在这个codata上做fold，最终就能拿到解，唯一的问题就是如何去构造这样一个codata。
- 感觉还有很多很多技巧，还有很多数学知识和算法以及编程语言理论，真的详细去写的话一本书都写不下，这里仅仅是抛砖引玉，我担心我没时间写下去没能记录下来这些想法。如果你觉得有趣的话不妨一起来探索。